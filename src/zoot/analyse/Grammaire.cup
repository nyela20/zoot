package zoot.analyse ;

import java.util.*;
import zoot.arbre.* ;
import zoot.arbre.declaration.* ;
import zoot.arbre.instructions.* ;
import zoot.exceptions.AnalyseSyntaxiqueException;

import java_cup.runtime.*;

action code {:
             :} ;

parser code {:

    public void report_error(String message, Object info) {

        HashMap<Integer, String> lesTerminaux = new HashMap<>() ;

        lesTerminaux.put(new Integer(CodesLexicaux.VARIABLES), "variables") ;
        lesTerminaux.put(new Integer(CodesLexicaux.FONCTIONS), "fonctions") ;
        lesTerminaux.put(new Integer(CodesLexicaux.DEBUT), "debut") ;
        lesTerminaux.put(new Integer(CodesLexicaux.FIN), "fin") ;
        lesTerminaux.put(new Integer(CodesLexicaux.POINTVIRGULE), ";") ;

        StringBuffer m = new StringBuffer() ;

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {
                m.append("ligne " + (s.left + 1)) ;
                if (s.right >= 0)
                    m.append(" colonne " + (s.right+1)) ;
            }

            if (s.value != null) {
                lesTerminaux.put(CodesLexicaux.CSTENTIERE, "" + s.value) ;
            }

            if (lesTerminaux.containsKey(new Integer(s.sym))) {
                m.append(" : dernier token lu : " + lesTerminaux.get(new Integer(s.sym))) ;
            }
            else {
                m.append(" : expression non termin√©e ") ;
            }

        }
        throw new AnalyseSyntaxiqueException("" + m) ;
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }
:};

/* ------------Declaration of Terminals and Non Terminals Section----------- */

/* Terminals (tokens returned by the scanner).  */

terminal Symbol    DEBUT, FIN, VARIABLES, FONCTIONS, POINTVIRGULE, ECRIRE, EGAL, PARO, PARF, RETOURNE;
terminal String    IDF, CSTENTIERE, CSTBOOLEENNE, ENTIER, BOOLEEN ;

/* Non terminals used in the grammar section.  */

non terminal BlocPrincipale PROG ;
non terminal Bloc LINST, LINSTNULL ;
non terminal ArrayList<FonctionDeclaration> LFCT ;
non terminal Expression.Type TYPE ;
non terminal ArrayList<VariableDeclaration> LDCL, LDCLNULL ;
non terminal VariableDeclaration VAR ;
non terminal FonctionDeclaration FCT ;
non terminal Instruction INST ;
non terminal Expression EXP ;

/* ----------------------------Grammar Section-------------------- */

start with PROG ;

PROG    ::=     VARIABLES  LDCL:ld  FONCTIONS  LFCT:lf  DEBUT  LINST:li  FIN
                {:
                    BlocPrincipale blocPrincipale = new BlocPrincipale(lileft + 1);
                    for (VariableDeclaration vd : ld) {
                        //vd.invoke(false);
                    }

                    Bloc blocFonc = new Bloc(lfleft + 1);
                    for (FonctionDeclaration fonc : lf) {
                        blocFonc.ajouter(fonc.verifier());
                    }

                    blocPrincipale.setBlocFonctions(blocFonc);
                    blocPrincipale.setBlocInstructions(li);
                    RESULT = blocPrincipale ;
                :}
                ;

TYPE    ::=     BOOLEEN {:
                    RESULT = Expression.Type.BOOLEEN;
                    //RESULT = "booleen";
                :}
        |
                ENTIER {:
                    RESULT = Expression.Type.ENTIER;
                    //RESULT = "entier";
                :}
                ;

LDCL    ::=     LDCL:ld  VAR:v
                {:
                    ld.add(v);
                    RESULT = ld;
                :}
        |
                VAR:v
                {:
                    ArrayList<VariableDeclaration> list = new ArrayList<VariableDeclaration>();
                    list.add(v);
                    RESULT = list;
                :}
                ;

VAR     ::=     TYPE:t  IDF:i  POINTVIRGULE
                {:
                    RESULT = new VariableDeclaration(new EntreeVariable(i), new SymboleVariable(t), tleft + 1);
                :}
                ;

LFCT   ::=     LFCT:lf  FCT:f
                {:
                    RESULT = lf;
                :}
        |
                FCT:f
                {:
                    ArrayList<FonctionDeclaration> lf = new ArrayList<FonctionDeclaration>();
                    lf.add(f);
                    RESULT = lf;
                :}
                ;

FCT ::=    TYPE:t  IDF:i  PARO PARF  DEBUT   LINST:li  FIN
                {:
                    Fonction f = new Fonction(i, li, tleft + 1);
                    RESULT = new FonctionDeclaration(f, t, tleft + 1);
                :}
                ;

LDCLNULL  ::=   LDCL:ld
                {:
                    RESULT = ld;
                :}
          |
                // vide
                {: RESULT = new ArrayList<VariableDeclaration>(); :}
                ;

PARAMETRES ::=  PARO  PARF
                {:
                    RESULT = new ArrayList<VariableDeclaration>();
                :}
                |
                PARO LDCL:LDCL PARF
                {:
                    RESULT = LDCL;
                :}
                ;

LINST   ::=     LINST:bloc  INST:i
                {:
                    bloc.ajouter(i);
                    RESULT = bloc;
                :}
        |
                INST:i
                {:
                    Bloc b = new Bloc(ileft + 1);
                    b.ajouter(i);
                    RESULT = b;
                :}
                ;

LINSTNULL ::=   LINST:linst
                {:
                    RESULT = linst;
                :}
          |
                // vide
                {:RESULT = new Bloc(0); :}
                ;

INST    ::=     ECRIRE EXP:e POINTVIRGULE
                {:
                    RESULT = new Ecrire(e, eleft + 1) ;
                :}
        |
                IDF:i EGAL EXP:e POINTVIRGULE
                {:
                    RESULT = new Affectation(new Identifiant(i, ileft + 1), e, ileft + 1);
                 :}
        |
                RETOURNE EXP:e POINTVIRGULE
                {:
                    RESULT = new Retourne(e, eleft + 1);
                :}
        ;

EXP    ::=      CSTENTIERE:c
                {:
                    RESULT = new ConstanteEntiere(c, cleft + 1) ;
                :}
        |
                CSTBOOLEENNE:c
                {:
                    boolean b = false;
                    if(c == "vrai") b = true;
                    RESULT = new ConstanteBooleenne(b, cleft + 1);
                :}
        |
                IDF:i
                {:
                    RESULT = new Identifiant(i, ileft + 1);
                :}
        |
                IDF:i PARO  PARF
                {:
                    RESULT = new AppelFonction(i, ileft + 1);
                :}
        ;
